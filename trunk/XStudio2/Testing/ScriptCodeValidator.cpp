#include "stdafx.h"
#include "ScriptValidator.h"
#include "../Logic/SyntaxLibrary.h"

namespace Testing
{
   namespace Scripts
   {
   
      // -------------------------------- CONSTRUCTION --------------------------------

      /// <summary>Creates source value read from an input stream</summary>
      /// <param name="src">The input stream</param>
      /// <exception cref="Logic::ArgumentException">Stream is not readable</exception>
      /// <exception cref="Logic::ArgumentNullException">Stream is null</exception>
      /// <exception cref="Logic::ComException">COM Error</exception>
      /// <exception cref="Logic::FileFormatException">File format is corrupt</exception>
      /// <exception cref="Logic::IOException">An I/O error occurred</exception>
      ScriptCodeValidator::ScriptCodeValidator(StreamPtr orig, StreamPtr copy)
         : In(orig), Out(copy)
      {
      }

      // ------------------------------- STATIC METHODS -------------------------------
      
      /// <summary>Create text mismatch exception</summary>
      /// <param name="src">throw source.</param>
      /// <param name="prop">name of property that mismatches</param>
      /// <param name="a">original</param>
      /// <param name="b">copy</param>
      /// <returns></returns>
      ValidationException  ScriptCodeValidator::CodeMismatch(const GuiString& src, const GuiString& prop, const GuiString& a, const GuiString& b)
      {
         return ValidationException(src, GuiString(L"code mismatch: %s\n  original='%s'\n  copy='%s'\n", prop.c_str(), a.c_str(), b.c_str()) );
      }

      /// <summary>Create text mismatch exception</summary>
      /// <param name="src">throw source.</param>
      /// <param name="prop">name of property that mismatches</param>
      /// <param name="a">original</param>
      /// <param name="b">copy</param>
      /// <returns></returns>
      ValidationException  ScriptCodeValidator::CodeMismatch(const GuiString& src, const GuiString& prop, const ParameterValue& a, const ParameterValue& b)
      {
         GuiString v1 = (a.Type == ValueType::String ? a.String : GuiString(L"0x%08X  (%d)", a.Int, a.Int));
         GuiString v2 = (b.Type == ValueType::String ? b.String : GuiString(L"0x%08X  (%d)", b.Int, b.Int));

         return CodeMismatch(src, prop, v1, v2);
      }
      
      /// <summary>Create text mismatch exception</summary>
      /// <param name="src">throw source.</param>
      /// <param name="prop">name of property that mismatches</param>
      /// <param name="a">original</param>
      /// <param name="b">copy</param>
      /// <returns></returns>
      ValidationException  ScriptCodeValidator::CodeMismatch(const GuiString& src, const GuiString& prop, int a, int b)
      {
         auto v1 = GuiString(L"0x%08X  (%d)", a, a);
         auto v2 = GuiString(L"0x%08X  (%d)", b, b);

         return CodeMismatch(src, prop, v1, v2);
      }

      // ------------------------------- PUBLIC METHODS -------------------------------
      
      /// <summary>Perform comparison of commands generated by compiler between script and it's validation copy</summary>
      bool  ScriptCodeValidator::Compare()
      {
         // Properties
         Compare(In.CodeArray, Out.CodeArray, 0, L"script name");
         //Compare(In.CodeArray, Out.CodeArray, 1, L"script engine version");
         Compare(In.CodeArray, Out.CodeArray, 2, L"script description");
         Compare(In.CodeArray, Out.CodeArray, 3, L"script version");
         Compare(In.CodeArray, Out.CodeArray, 4, L"script live data flag");
         Compare(In.CodeArray, Out.CodeArray, 9, L"script command ID");

         // Data + Code
         CompareVariables();
         CompareArguments();
         CompareCommands();
         return true;
      }

      // ------------------------------ PROTECTED METHODS -----------------------------

      // ------------------------------- PRIVATE METHODS ------------------------------
      
      /// <summary>Compare type and value of two nodes</summary>
      bool  ScriptCodeValidator::Compare(XmlNodePtr parent_in, XmlNodePtr parent_out, UINT index, GuiString help)
      {
         // Read nodes
         auto v1 = In.ReadValue(parent_in, index, help.c_str());
         auto v2 = Out.ReadValue(parent_out, index, help.c_str());

         // Compare content
         if (v1 != v2)
            throw CodeMismatch(HERE, help, v1, v2);

         return true;
      }

      /// <summary>Compare argument branches</summary>
      void  ScriptCodeValidator::CompareArguments()
      {
         // Branch size
         CompareSize(In.CodeArray, Out.CodeArray, 7, L"arguments branch size");

         // Arguments
         auto in_args = In.GetChild(In.CodeArray, 7, L"arguments branch");
         auto out_args = Out.GetChild(Out.CodeArray, 7, L"arguments branch");

         for (int i = 0; i < in_args->childNodes->length; i++)
         {
            // Property count
            CompareSize(in_args, out_args, i, GuiString(L"argument %d sub-branch size", i+1));
            
            // Get sub-branch
            auto in_arg = In.GetChild(in_args, i, GuiString(L"argument %d sub-branch", i+1).c_str());
            auto out_arg = Out.GetChild(out_args, i, GuiString(L"argument %d sub-branch", i+1).c_str());
            
            // argument type/description
            Compare(in_arg, out_arg, 0, GuiString(L"argument %d type", i+1));
            Compare(in_arg, out_arg, 1, GuiString(L"argument %d description", i+1));
         }
      }

      /// <summary>Compare standard command branches</summary>
      void  ScriptCodeValidator::CompareCommands()
      {
         // Verify branch sizes
         CompareSize(In.CodeArray, Out.CodeArray, 6, L"std commands branch size");
         //CompareSize(In.CodeArray, Out.CodeArray, 8, L"aux commands branch size");

         // Std Commands
         auto in_cmds = In.GetChild(In.CodeArray, 6, L"std commands branch");
         auto out_cmds = Out.GetChild(Out.CodeArray, 6, L"std commands branch");

         for (int i = 0; i < in_cmds->childNodes->length; i++)
         {
            auto line = GuiString(L"(std %d) : ", i+1);

            try
            {
               // Get command branch
               auto in_cmd = In.GetChild(in_cmds, i, (line+L"sub-branch").c_str());
               auto out_cmd = Out.GetChild(out_cmds, i, (line+L"sub-branch").c_str());

               // Get command ID
               Compare(in_cmd, out_cmd, 0, line + L"command ID");
               CommandSyntax syntax = SyntaxLib.Find(In.ReadInt(in_cmd, 0, (line+L"command ID").c_str()), GameVersion::TerranConflict);

               // Improve location description
               line = GuiString(L"(std %d) '%s' : ", i+1, syntax.Text.c_str());

               // Node count
               CompareSize(in_cmds, out_cmds, i, line+L"node count");
            
               // parameters
               UINT nodeIndex = 1, paramIndex = 1;
               for (ParameterSyntax p : syntax.Parameters)
               {
                  GuiString paramId(line + GuiString(L" param %d of %d : ", paramIndex++, syntax.Parameters.size()) + GetString(p.Type));
                  DataType  dt = DataType::UNKNOWN;

                  try
                  {
                     switch (p.Type)
                     {
                     // Single node
                     case ParameterType::COMMENT:        
                     case ParameterType::SCRIPT_NAME:    
                     case ParameterType::LABEL_NAME:     
                     case ParameterType::LABEL_NUMBER: 
                     case ParameterType::VARIABLE:          // Old 'var' parameter
                     case ParameterType::RETURN_VALUE:      
                     case ParameterType::RETURN_VALUE_IF:
                     case ParameterType::RETURN_VALUE_IF_START:
                     case ParameterType::INTERRUPT_RETURN_VALUE_IF: 
                        Compare(in_cmd, out_cmd, nodeIndex, paramId);
                        break;
                        
                     // Parameter as {Type,Value} pair
                     default:
                        dt = (DataType)In.ReadInt(in_cmd, nodeIndex, (paramId+L" DataType").c_str());

                        Compare(in_cmd, out_cmd, nodeIndex, line+paramId+GetString(p.Type)+L" (type)");
                        Compare(in_cmd, out_cmd, nodeIndex, line+paramId+GetString(p.Type)+L" (value)");
                        
                        ++nodeIndex;
                        break;
                     }
                  }
                  // Comparison failed: Print details of value
                  catch (ValidationException& e) 
                  {
                     Console.Log(HERE, e);

                     // Read values
                     int in_val  = In.ReadInt(in_cmd, nodeIndex, (paramId+L" Value").c_str()),
                         out_val = In.ReadInt(out_cmd, nodeIndex, (paramId+L" Value").c_str());
                     
                     // Print Variable names
                     switch (p.Type)
                     {
                     case ParameterType::COMMENT:        
                     case ParameterType::SCRIPT_NAME:    
                     case ParameterType::LABEL_NAME:     
                     case ParameterType::LABEL_NUMBER: 
                        break;

                     // Var/RetVar
                     case ParameterType::VARIABLE:          // Old 'var' parameter
                     case ParameterType::RETURN_VALUE:      
                     case ParameterType::RETURN_VALUE_IF:
                     case ParameterType::RETURN_VALUE_IF_START:
                     case ParameterType::INTERRUPT_RETURN_VALUE_IF: 
                        // Return Value: Print components
                        if (in_val < 0 || out_val < 0)  
                        {
                           Console << L"  Original RetVal: " << ReturnValue(in_val) << ENDL;
                           Console << L"  Copy RetVal: " << ReturnValue(out_val) << ENDL;
                           break;
                        }
                        else // RetVar: Print names
                           dt = DataType::VARIABLE;
                           // Fall thru...

                     // Parameter as {Type,Value} pair
                     default:
                        // Variable: Print names
                        if (dt == DataType::VARIABLE && in_val >= 0 && out_val >= 0)
                        {
                           Console << L"  Original var: " << InVars[in_val] << ENDL;
                           Console << L"  Copy var: " << OutVars[out_val] << ENDL;
                        }

                        ++nodeIndex;  // Re-align node index
                        break;
                     }
                  }

                  ++nodeIndex;
               }
            }
            catch (ValidationException& e) {
               Console.Log(HERE, e);
            }
         }
      }


      /// <summary>Compare size of two array nodes</summary>
      bool  ScriptCodeValidator::CompareSize(XmlNodePtr parent_in, XmlNodePtr parent_out, UINT index, GuiString help)
      {
         // Read sizes
         auto v1 = In.ReadArray(parent_in, index, help.c_str());
         auto v2 = Out.ReadArray(parent_out, index, help.c_str());

         // Compare size
         if (v1 != v2)
            throw CodeMismatch(HERE, help, v1, v2);

         return true;
      }

      
      /// <summary>Compare variables branches</summary>
      void  ScriptCodeValidator::CompareVariables()
      {
         // Verify branch size
         CompareSize(In.CodeArray, Out.CodeArray, 5, L"variables branch size");

         // Get branches
         auto in_vars = In.GetChild(In.CodeArray, 5, L"variables branch");
         auto out_vars = Out.GetChild(Out.CodeArray, 5, L"variables branch");

         // Compare names/order
         for (int i = 0; i < in_vars->childNodes->length; i++)
         {
            Compare(in_vars, out_vars, i, GuiString(L"variable %d of %d", i+1, in_vars->childNodes->length));

            // Store for name resolution
            InVars.push_back( ScriptVariable(In.ReadString(in_vars, i, L"variable name"), i) );
            OutVars.push_back( ScriptVariable(Out.ReadString(out_vars, i, L"variable name"), i) );
         }
         
      }

   }
}

